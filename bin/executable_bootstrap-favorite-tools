#!/usr/bin/env python3

import argparse
import os
import platform
import subprocess
import sys
from pathlib import Path

HOME = os.path.expanduser("~")
DRYRUN = False
PACKAGES = [
    "bat",  # https://github.com/sharkdp/bat
    "curlie",  # https://github.com/rs/curlie
    "delta",  # https://github.com/dandavison/delta
    "dua",  # https://github.com/Byron/dua-cli
    "duf",  # https://github.com/muesli/duf
    "eza",  # https://github.com/eza-community/eza
    "fd",  # https://github.com/sharkdp/fd
    "htop",  # https://htop.dev/
    "ripgrep",  # https://github.com/BurntSushi/ripgrep
    "tre",  # https://github.com/dduan/tre
    "tmux",  # https://github.com/tmux/tmux
    "tokei",  # https://github.com/XAMPPRocky/tokei
    "wget",  # https://www.gnu.org/software/wget/
]
COMMAND_NAMES = {
    "ripgrep": "rg",
}
PACKAGER_NAMES = {
    "tre": "tre-command",
    "delta": "git-delta",
}


def bold(text):
    return f"\033[1m{text}\033[0m"


def dim(text):
    return f"\033[2m{text}\033[0m"


def highlighted(text):
    return f"\033[35m{text}\033[0m"


def red(text):
    return f"\033[31m{text}\033[0m"


def short(text):
    return str(text).replace(HOME, "~")


def hdry(message, dryrun=None):
    """Helps handle dryrun"""
    if dryrun is None:
        dryrun = DRYRUN

    if dryrun:
        print(message)
        return True


def run_program(program, *args, **kwargs):
    fatal = kwargs.pop("fatal", True)
    description = " ".join(short(x) for x in args)
    description = f"{short(program)} {description}"
    if not hdry(f"{highlighted('Would run:')} {description}", dryrun=kwargs.pop("dryrun", None)):
        print(f"{highlighted('Running:')} {description}")
        if fatal:
            stdout = stderr = None

        else:
            stdout = stderr = subprocess.PIPE

        p = subprocess.Popen([program, *args], stdout=stdout, stderr=stderr, env=kwargs.pop("env", None))
        if fatal:
            p.wait()
            if p.returncode:
                sys.exit(f"'{short(program)}' exited with code {p.returncode}")

            return p.returncode

        output, _ = p.communicate()
        if output is not None:
            output = output.decode("utf-8").strip()

        return None if p.returncode else output


def is_executable(path):
    return path and os.path.isfile(path) and os.access(path, os.X_OK)


def which(program):
    prefix_bin = os.path.join(sys.prefix, "bin")
    for p in os.environ.get("PATH", "").split(os.pathsep):
        if p != prefix_bin:
            fp = os.path.join(p, program)
            if fp and is_executable(fp):
                return Path(fp)


class Installer:

    packager = None
    command_names = {}
    package_names = {}

    @classmethod
    def for_current_platform(cls):
        if  platform.system() == "Darwin":
            return BrewBased()

        if which("apt-get"):
            return AptBased()

    def resolved_command_name(self, command_name):
        return self.command_names.get(command_name) or COMMAND_NAMES.get(command_name) or command_name

    def resolved_package_name(self, package_name):
        if package_name in self.package_names:
            return self.package_names[package_name]

        return PACKAGER_NAMES.get(package_name) or package_name

    def update(self):
        """Update installer metadata"""

    def install(self, package_name):
        """Install a package"""
        actual_command_name = self.resolved_command_name(package_name)
        if which(actual_command_name):
            print(f"{bold(package_name)} {dim('already installed')}")
            return

        actual_package = self.resolved_package_name(package_name)
        if not actual_package:
            print(f"{bold(package_name)} {red('not available')} with {highlighted(self.packager)}, skipping")
            return

        self._install(actual_package)

    def _install(self, package_name):
        """Implemented in descendants"""


class AptBased(Installer):

    packager = "apt-get"
    command_names = {"bat": "batcat"}
    package_names = {"delta": None, "dua": None, "fd": "fd-find", "tokei": None}

    def update(self):
        run_program("sudo", "apt-get", "update")

    def _install(self, package_name):
        run_program("sudo", "apt-get", "install", "-y", package_name)


class BrewBased(Installer):

    packager = "brew"
    package_names = {"dua": "dua-cli"}

    # def update(self):
    #     run_program("brew", "update")

    def _install(self, package_name):
        run_program("brew", "install", package_name)


def main(args=None):
    """Auto-install favorite tools"""
    global DRYRUN

    parser = argparse.ArgumentParser(description=main.__doc__)
    parser.add_argument("--dryrun", "-n", action="store_true", help="Perform a dryrun")
    args = parser.parse_args(args=args)

    DRYRUN = args.dryrun
    installer = Installer.for_current_platform()
    if not installer:
        sys.exit("No installer defined for current platform")

    installer.update()
    for package in PACKAGES:
        installer.install(package)


if __name__ == "__main__":
    main()
